"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[562],{202:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"usage/custom-endpoint","title":"Custom Endpoint & Fetcher","description":"Pixstore includes a default image fetcher and a built-in backend HTTP endpoint.","source":"@site/docs/usage/custom-fetcher.md","sourceDirName":"usage","slug":"/usage/custom-endpoint","permalink":"/pixstore/docs/usage/custom-endpoint","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/usage/custom-fetcher.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"custom-endpoint","title":"Custom Endpoint & Fetcher","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Default Endpoint & Fetcher","permalink":"/pixstore/docs/usage/default-endpoint"},"next":{"title":"Automatic Cache Cleanup","permalink":"/pixstore/docs/usage/cache-cleanup"}}');var r=t(4848),i=t(8453);const o={id:"custom-endpoint",title:"Custom Endpoint & Fetcher",sidebar_position:6},a=void 0,d={},c=[{value:"Creating a Custom Image Endpoint on the Backend",id:"creating-a-custom-image-endpoint-on-the-backend",level:2},{value:"Registering a Custom Fetcher on the Frontend",id:"registering-a-custom-fetcher-on-the-frontend",level:2},{value:"What can you do with custom endpoints?",id:"what-can-you-do-with-custom-endpoints",level:2},{value:"Pixstore Wire Format",id:"pixstore-wire-format",level:2},{value:"Key rules:",id:"key-rules",level:3},{value:"Common <code>WirePayloadState</code> values:",id:"common-wirepayloadstate-values",level:3},{value:"Minimal vs Full Metadata Responses",id:"minimal-vs-full-metadata-responses",level:2},{value:"See also",id:"see-also",level:2}];function l(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Pixstore includes a default image fetcher and a built-in backend HTTP endpoint.\nWith these defaults, images are fetched automatically with minimal configuration."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"/docs/usage/default-endpoint",children:(0,r.jsx)(n.strong,{children:"default endpoint"})})," is secure by design: it verifies ",(0,r.jsx)(n.a,{href:"/docs/usage/integration#stateless-proof-mechanism",children:(0,r.jsx)(n.strong,{children:"stateless proof"})})," for every request and only serves images that were explicitly authorized by your backend.\nThis mechanism protects your images from unauthorized access, even if someone knows the image ID."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need ",(0,r.jsx)(n.strong,{children:"additional protection"}),", such as user-specific access control (for example JWT tokens or roles) or if you want to use a different transport (like WebSocket or gRPC),\nyou can implement a ",(0,r.jsx)(n.a,{href:"/docs/api-reference/backend/custom-endpoint#customendpointhelper",children:(0,r.jsx)(n.strong,{children:"custom image endpoint"})})," and register a ",(0,r.jsx)(n.a,{href:"/docs/api-reference/types#imagefetcher",children:(0,r.jsx)(n.strong,{children:"custom fetcher"})})," on the frontend."]}),"\n",(0,r.jsxs)(n.p,{children:["When you use a custom fetcher, Pixstore still enforces ",(0,r.jsx)(n.a,{href:"/docs/usage/integration#stateless-proof-mechanism",children:(0,r.jsx)(n.strong,{children:"stateless proof"})})," validation,\nensuring that only valid and time-bound image requests are processed.\nThis means you can combine ",(0,r.jsx)(n.strong,{children:"Pixstore's built-in security"})," with your own logic for authentication, rate limiting, analytics and more, all while preserving encryption, token-based caching and metadata management."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-custom-image-endpoint-on-the-backend",children:"Creating a Custom Image Endpoint on the Backend"}),"\n",(0,r.jsx)(n.p,{children:"You can build your own image endpoint using any backend framework (e.g. Express, Fastify).\nThis gives you full control over authentication and authorization logic."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Express.js with JWT + role check"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import express from 'express'\nimport { customEndpointHelper } from 'pixstore/backend'\n\nconst app = express()\n\napp.get('/player-image/:playerId/:imageId', async (req, res) => {\n  const { playerId, imageId } = req.params\n  const statelessProof = req.headers['x-pixstore-proof'] as string\n  const clientTokenRaw = req.query.token ?? req.headers['x-pixstore-token']\n  const clientToken = clientTokenRaw !== undefined ? Number(clientTokenRaw) : 0\n\n  // Optional: check JWT token, user roles, etc.\n  const user = verifyJwt(req.headers.authorization)\n  if (!canAccessImage(user, playerId)) {\n    return res.status(403).json({ error: 'Unauthorized' })\n  }\n\n  const payload = await customEndpointHelper(\n    imageId,\n    clientToken,\n    statelessProof,\n  )\n  if (!payload) {\n    return res.status(404).json({ error: 'Image not found' })\n  }\n\n  res.setHeader('Content-Type', 'application/octet-stream')\n  res.send(payload)\n})\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"registering-a-custom-fetcher-on-the-frontend",children:"Registering a Custom Fetcher on the Frontend"}),"\n",(0,r.jsxs)(n.p,{children:["To support your custom endpoint, register a custom fetcher during ",(0,r.jsx)(n.a,{href:"/docs/api-reference/frontend/initialization#initpixstorefrontend",children:(0,r.jsx)(n.code,{children:"initPixstoreFrontend"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: fetcher that adds Authorization and playerId"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { initPixstoreFrontend } from 'pixstore/frontend'\nimport type { ImageFetcher } from 'pixstore/types'\nimport { useAuth } from './auth-store'\n\nconst customFetcher: ImageFetcher = async (record, context) => {\n  const { playerId } = context as { playerId: string }\n  const jwt = useAuth.getState().jwt\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${jwt}`,\n    'x-pixstore-proof': record.statelessProof,\n  }\n  if (record.token !== undefined) {\n    headers['x-pixstore-token'] = String(record.token)\n  }\n\n  const res = await fetch(`/player-image/${playerId}/${record.id}`, {\n    method: 'GET',\n    headers,\n  })\n\n  if (!res.ok) throw new Error('Failed to fetch image')\n  const buffer = await res.arrayBuffer()\n  return new Uint8Array(buffer)\n}\n\ninitPixstoreFrontend(\n  {\n    // Pixstore config such as cache limits, error handling mode etc.\n  },\n  customFetcher,\n)\n"})}),"\n",(0,r.jsxs)(n.admonition,{title:"Context support",type:"note",children:[(0,r.jsxs)(n.p,{children:["The second argument to your custom fetcher is a ",(0,r.jsx)(n.code,{children:"context"})," object.\nYou can pass in values like ",(0,r.jsx)(n.code,{children:"playerId"}),", user roles, etc. from your app code:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"getImage(record, { playerId: 42 })\n"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"what-can-you-do-with-custom-endpoints",children:"What can you do with custom endpoints?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enforce role-based access for each image"}),"\n",(0,r.jsx)(n.li,{children:"Use custom headers, authentication, or request libraries"}),"\n",(0,r.jsx)(n.li,{children:"Fetch images via non-HTTP protocols (WebSocket, gRPC, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Integrate advanced logging, rate limiting, or caching logic"}),"\n",(0,r.jsx)(n.li,{children:"Load from third-party storage systems (e.g. AWS S3)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Pixstore handles decryption, wire format, and local caching.\nYou control when and how images are served securely."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pixstore-wire-format",children:"Pixstore Wire Format"}),"\n",(0,r.jsxs)(n.p,{children:["When you create a ",(0,r.jsx)(n.strong,{children:"custom endpoint"})," or a ",(0,r.jsx)(n.strong,{children:"custom fetcher"}),", all image data flows through Pixstore\u2019s internal ",(0,r.jsx)(n.strong,{children:"wire format"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This format ensures encrypted data, tokens, and decryption metadata are transmitted efficiently and securely, without exposing sensitive internals."}),"\n",(0,r.jsx)(n.h3,{id:"key-rules",children:"Key rules:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Your backend ",(0,r.jsx)(n.strong,{children:"must return"})," a binary ",(0,r.jsx)(n.code,{children:"Uint8Array"})," payload (e.g. via ",(0,r.jsx)(n.code,{children:"customEndpointHelper()"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Your custom fetcher ",(0,r.jsx)(n.strong,{children:"must return"})," the same ",(0,r.jsx)(n.code,{children:"Uint8Array"})," payload to Pixstore."]}),"\n",(0,r.jsx)(n.li,{children:"The format is always decoded on the frontend using Pixstore\u2019s internal decoder."}),"\n",(0,r.jsxs)(n.li,{children:["Every request should return HTTP ",(0,r.jsx)(n.code,{children:"200"}),". ",(0,r.jsx)(n.strong,{children:"Errors"})," are expressed using a ",(0,r.jsx)(n.code,{children:"state"})," field inside the binary payload."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Pixstore uses this layout internally to encode and decode wire payloads. You ",(0,r.jsx)(n.strong,{children:"must not"})," return plain JSON or raw image buffers, always use this binary format."]}),"\n",(0,r.jsxs)(n.h3,{id:"common-wirepayloadstate-values",children:["Common ",(0,r.jsx)(n.code,{children:"WirePayloadState"})," values:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"State"}),(0,r.jsx)(n.th,{children:"Meaning"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Success = 0"})}),(0,r.jsx)(n.td,{children:"Image cached and valid, returns minimal response"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Updated = 1"})}),(0,r.jsx)(n.td,{children:"Token mismatch, returns full metadata"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NotFound = 2"})}),(0,r.jsx)(n.td,{children:"Image not found on server"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"MissingProof"})}),(0,r.jsx)(n.td,{children:"Stateless proof was not provided"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"InvalidProof"})}),(0,r.jsx)(n.td,{children:"Stateless proof was expired or invalid"})]})]})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["All custom endpoints should return status ",(0,r.jsx)(n.code,{children:"200"}),", even in error cases. Pixstore decodes the ",(0,r.jsx)(n.code,{children:"state"})," from the wire payload itself."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"minimal-vs-full-metadata-responses",children:"Minimal vs Full Metadata Responses"}),"\n",(0,r.jsxs)(n.p,{children:["Pixstore is optimized to send the ",(0,r.jsx)(n.strong,{children:"smallest possible payload"})," when the image is already cached and valid."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If the ",(0,r.jsx)(n.code,{children:"token"})," in your ",(0,r.jsx)(n.code,{children:"imageRecord"})," matches the backend token, Pixstore returns a ",(0,r.jsx)(n.strong,{children:"minimal payload"})," containing only the encrypted image."]}),"\n",(0,r.jsxs)(n.li,{children:["If the token is outdated, Pixstore returns a ",(0,r.jsx)(n.strong,{children:"full payload"})," with updated encryption metadata (",(0,r.jsx)(n.code,{children:"meta"}),") and the new token."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This mechanism is fully automated, but only works correctly if the ",(0,r.jsx)(n.code,{children:"clientToken"})," is passed to the backend."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,r.jsx)(n.strong,{children:"Important:"})," When using a ",(0,r.jsx)(n.a,{href:"/docs/api-reference/backend/custom-endpoint#customendpointhelper",children:"custom image endpoint helper"}),", always pass the ",(0,r.jsx)(n.code,{children:"clientToken"}),".\nIf this is omitted, Pixstore cannot determine whether the image is cached correctly, and will ",(0,r.jsx)(n.strong,{children:"always return full metadata"}),", increasing payload size and wasting resources."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["A minimal response is ideal in nearly all cases.\nFull metadata is only returned ",(0,r.jsx)(n.strong,{children:"if the image was updated recently"}),", and the frontend's token is stale."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/backend/custom-endpoint",children:"API Reference \u2013 customEndpointHelper()"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/types#imagefetcher",children:"API Reference \u2013 ImageFetcher"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/usage/integration#stateless-proof-mechanism",children:"Usage \u2013 Stateless proof mechanism"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);