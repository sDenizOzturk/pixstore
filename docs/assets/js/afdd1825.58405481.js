"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[74],{2957:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>o});const d=JSON.parse('{"id":"reference/frontend/image-service","title":"Image Service","description":"This module provides high-level functions to retrieve and manage encrypted images on the frontend.","source":"@site/docs/reference/frontend/image-service.md","sourceDirName":"reference/frontend","slug":"/reference/frontend/image-service","permalink":"/pixstore/docs/reference/frontend/image-service","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/reference/frontend/image-service.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"image-service","title":"Image Service","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Initialization","permalink":"/pixstore/docs/reference/frontend/initialization"},"next":{"title":"Shared Types","permalink":"/pixstore/docs/reference/types"}}');var r=t(4848),a=t(8453);const i={id:"image-service",title:"Image Service",sidebar_position:2},c="Image Service",s={},o=[{value:"<code>getImage</code>",id:"getimage",level:2},{value:"Description",id:"description",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Example",id:"example",level:3},{value:"How it works?",id:"how-it-works",level:3},{value:"<code>deleteCachedImage</code>",id:"deletecachedimage",level:2},{value:"Description",id:"description-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Example",id:"example-1",level:3},{value:"How it works?",id:"how-it-works-1",level:3},{value:"<code>cachedImageExists</code>",id:"cachedimageexists",level:2},{value:"Description",id:"description-2",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Example",id:"example-2",level:3},{value:"How it works?",id:"how-it-works-2",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"image-service",children:"Image Service"})}),"\n",(0,r.jsx)(n.p,{children:"This module provides high-level functions to retrieve and manage encrypted images on the frontend."}),"\n",(0,r.jsx)(n.p,{children:"It automatically fetches the image from the backend (using either the default endpoint or a custom fetcher), decrypts it using AES-GCM, and caches the result in IndexedDB for future access."}),"\n",(0,r.jsxs)(n.p,{children:["All functions are exported from the ",(0,r.jsx)(n.code,{children:"pixstore/frontend"})," entrypoint:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  getImage,\n  deleteCachedImage,\n  cachedImageExists,\n} from 'pixstore/frontend'\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each function is described in detail below."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"getimage",children:(0,r.jsx)(n.code,{children:"getImage"})}),"\n",(0,r.jsx)(n.p,{children:"Retrieves and decrypts an image using token-based cache validation."}),"\n",(0,r.jsxs)(n.p,{children:["If the image is already cached in IndexedDB ",(0,r.jsx)(n.strong,{children:"and"})," the token matches, it is decrypted and returned directly.\nOtherwise, the image is fetched from the backend in encrypted wire format, decoded, cached, and then decrypted before returning as a ",(0,r.jsx)(n.code,{children:"Blob"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const getImage = (\n  record: ImageRecord,\n  context?: any\n): Promise<Blob>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"record"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ImageRecord"})}),(0,r.jsxs)(n.td,{children:["Metadata object received from backend (",(0,r.jsx)(n.code,{children:"id"}),", ",(0,r.jsx)(n.code,{children:"token"}),", and ",(0,r.jsx)(n.code,{children:"meta"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"context"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"any?"})}),(0,r.jsx)(n.td,{children:"Optional data passed to a custom image fetcher (if configured on frontend)"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"try {\n  const blob = await getImage(imageRecord)\n  const url = URL.createObjectURL(blob)\n  // ...use in <img> or wherever\n} catch {\n  // show fallback, placeholder, etc.\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:"How it works?"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"/**\n * Retrieves image data using token-based cache validation.\n * Returns the cached Blob if token matches; otherwise fetches, updates, and returns new Blob.\n */\nexport const getImage = async (\n  record: ImageRecord,\n  context?: any,\n): Promise<Blob> => {\n  // Attempt to read the cached image from IndexedDB by ID\n  const { id, token, meta } = record\n  const cached = await readImageRecord(id)\n\n  // If a cached image exists and the token matches, return it immediately\n  if (cached && cached.token === token) {\n    const indexedDBRecord = await readImageRecord(id)\n    const encrypted = indexedDBRecord!.encrypted\n\n    // Decrypt the image using the extracted encrypted data and meta\n    const imagePayload = await decryptImage(encrypted, meta)\n\n    // Return the up-to-date Blob for rendering\n    return decryptedPayloadToBlob(imagePayload)\n  }\n\n  // Otherwise, fetch the latest encoded image from the backend\n  const encoded = await fetchEncodedImage(record.id, context)\n\n  // Decode the wire payload to extract encrypted data, meta, and token\n  const decodedWirePayload = decodeWirePayload(encoded)\n\n  // Prepare the IndexedDB record with fresh encrypted data and token\n  const indexedDBRecord: IndexedDBImageRecord = {\n    id,\n    encrypted: decodedWirePayload.encrypted,\n    token: decodedWirePayload.token,\n    lastUsed: Date.now(),\n  }\n\n  // Save the updated image into the local cache\n  await writeImageRecord(indexedDBRecord)\n\n  // Decrypt the image using the encrypted data and meta from the wire payload.\n  // The `record.meta` is not used, using stale meta could break decryption if the image was recently updated.\n  const imagePayload = await decryptImage(\n    decodedWirePayload.encrypted,\n    decodedWirePayload.meta,\n  )\n\n  // Return the up-to-date Blob for rendering\n  return decryptedPayloadToBlob(imagePayload)\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"deletecachedimage",children:(0,r.jsx)(n.code,{children:"deleteCachedImage"})}),"\n",(0,r.jsx)(n.p,{children:"Removes an image from the local IndexedDB cache by its ID.\nUseful when you want to manually clear outdated or unused images from the frontend cache."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"description-1",children:"Description"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const deleteCachedImage = (\n  id: string\n): Promise<void>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"id"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"ID of the cached image to delete."})]})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { deleteCachedImage } from 'pixstore/frontend'\n\nawait deleteCachedImage(imageId)\n\n// Optional: update UI or local state\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works-1",children:"How it works?"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"/**\n * Removes a cached image from IndexedDB.\n */\nexport const deleteCachedImage = async (id: string): Promise<void> => {\n  // Deletes the image record (by ID) from the local IndexedDB cache\n  await deleteImageRecord(id)\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cachedimageexists",children:(0,r.jsx)(n.code,{children:"cachedImageExists"})}),"\n",(0,r.jsx)(n.p,{children:"Checks whether a cached image exists in the local IndexedDB by its ID."}),"\n",(0,r.jsx)(n.p,{children:"This can be used to conditionally load or invalidate image data before making a network request."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"description-2",children:"Description"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export const cachedImageExists = (\n  id: string\n): Promise<boolean>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"id"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"ID of the image to check in the cache."})]})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { cachedImageExists } from 'pixstore/frontend'\n\nconst exists = await cachedImageExists(imageId)\n\nif (exists) {\n  console.log('Image is available locally.')\n} else {\n  console.log('Image needs to be fetched.')\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works-2",children:"How it works?"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"/**\n * Returns true if a cached image exists in IndexedDB for the given id.\n */\nexport const cachedImageExists = async (id: string): Promise<boolean> => {\n  // Checks IndexedDB for an image record with the specified ID\n  return await imageRecordExists(id)\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["\ud83d\udcc4 Source: ",(0,r.jsx)(n.a,{href:"https://github.com/sDenizOzturk/pixstore/blob/main/src/frontend/image-service.ts",children:(0,r.jsx)(n.code,{children:"src/frontend/image-service.ts"})})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var d=t(6540);const r={},a=d.createContext(r);function i(e){const n=d.useContext(a);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),d.createElement(a.Provider,{value:n},e.children)}}}]);