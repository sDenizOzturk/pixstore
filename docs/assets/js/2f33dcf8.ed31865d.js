"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[592],{3141:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(4848);const d=t(8330).WD||" ",a=()=>(0,r.jsxs)("div",{style:{backgroundColor:"#fff4e5",padding:"1em",borderLeft:"4px solid #f5a623",marginBottom:"1em",borderRadius:"4px",fontSize:"0.8em",lineHeight:"1.4",color:"#333"},children:[(0,r.jsx)("strong",{children:"\u26a0\ufe0f This section shows internal implementation details."}),(0,r.jsx)("br",{}),"It is intended for contributors or users who want to understand the inner workings of Pixstore. Typical users do not need to modify or interact with this code directly.",(0,r.jsx)("br",{}),(0,r.jsxs)("em",{children:["Also, this code was last verified with",(0,r.jsxs)("b",{children:[" Pixstore v",d]})," and may change in future versions. For the latest implementation, always check the official repository at"," ",(0,r.jsx)("a",{href:"https://github.com/sDenizOzturk/pixstore",target:"_blank",rel:"noopener noreferrer",children:"github.com/sDenizOzturk/pixstore"}),"."]})]})},8141:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api-reference/frontend/image-service","title":"Image Service","description":"This module provides high-level functions to retrieve and manage encrypted images on the frontend.","source":"@site/docs/api-reference/frontend/image-service.md","sourceDirName":"api-reference/frontend","slug":"/api-reference/frontend/image-service","permalink":"/pixstore/docs/api-reference/frontend/image-service","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/api-reference/frontend/image-service.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"image-service","title":"Image Service","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Initialization","permalink":"/pixstore/docs/api-reference/frontend/initialization"},"next":{"title":"Shared Modules","permalink":"/pixstore/docs/api-reference/shared-module"}}');var d=t(4848),a=t(8453),s=t(3141);const i={id:"image-service",title:"Image Service",sidebar_position:2},c="Image Service",o={},l=[{value:"<code>getImage</code>",id:"getimage",level:2},{value:"Description",id:"description",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Example",id:"example",level:3},{value:"How it works?",id:"how-it-works",level:3},{value:"<code>deleteCachedImage</code>",id:"deletecachedimage",level:2},{value:"Description",id:"description-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Example",id:"example-1",level:3},{value:"How it works?",id:"how-it-works-1",level:3},{value:"<code>cachedImageExists</code>",id:"cachedimageexists",level:2},{value:"Description",id:"description-2",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Example",id:"example-2",level:3},{value:"How it works?",id:"how-it-works-2",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"image-service",children:"Image Service"})}),"\n",(0,d.jsx)(n.p,{children:"This module provides high-level functions to retrieve and manage encrypted images on the frontend."}),"\n",(0,d.jsx)(n.p,{children:"It automatically fetches the image from the backend (using either the default endpoint or a custom fetcher), decrypts it using AES-GCM, and caches the result in IndexedDB for future access."}),"\n",(0,d.jsxs)(n.p,{children:["All functions are exported from the ",(0,d.jsx)(n.code,{children:"pixstore/frontend"})," entrypoint:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"import {\n  getImage,\n  deleteCachedImage,\n  cachedImageExists,\n} from 'pixstore/frontend'\n"})}),"\n",(0,d.jsx)(n.p,{children:"Each function is described in detail below."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h2,{id:"getimage",children:(0,d.jsx)(n.code,{children:"getImage"})}),"\n",(0,d.jsx)(n.p,{children:"Retrieves and decrypts an image using token-based cache validation and stateless proof authorization."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["If the image is cached in IndexedDB ",(0,d.jsx)(n.strong,{children:"and"})," its token matches the provided ",(0,d.jsx)(n.code,{children:"record.token"}),", the cached encrypted data is decrypted and returned immediately as a ",(0,d.jsx)(n.code,{children:"Blob"}),"."]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["If the cached token differs from the provided ",(0,d.jsx)(n.code,{children:"record.token"})," (indicating a possible update elsewhere), a conditional fetch is made to the backend with the cached token:"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"The backend returns either a minimal payload if the image is unchanged (just after the imageRecord sent) or a full updated payload if changed."}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"The local cache is updated accordingly with the latest encrypted data and token."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"The image is always decrypted using the latest encrypted data and metadata (which may come from the cache or backend)."}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"This mechanism minimizes data transfer while ensuring the image cache is kept up to date."}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"export const getImage = (\n  record: ImageRecord,\n  context?: any\n): Promise<Blob | null>\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Name"}),(0,d.jsx)(n.th,{children:"Type"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"record"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"ImageRecord"})}),(0,d.jsxs)(n.td,{children:["Metadata object received from backend, including ",(0,d.jsx)(n.code,{children:"id"}),", ",(0,d.jsx)(n.code,{children:"token"}),", ",(0,d.jsx)(n.code,{children:"meta"}),", and ",(0,d.jsx)(n.code,{children:"statelessProof"})]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"context"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"any?"})}),(0,d.jsx)(n.td,{children:"Optional data passed to a custom image fetcher (if configured on frontend)"})]})]})]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"const blob = await getImage(imageRecord)\nif (blob) {\n  const url = URL.createObjectURL(blob)\n  // ...use in <img> or wherever\n} else {\n  // For error details, use:\n  console.error(getLastPixstoreError())\n  // show fallback, placeholder, etc.\n}\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"how-it-works",children:"How it works?"}),"\n",(0,d.jsx)(s.A,{}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"/**\n * Retrieves image data using token-based cache validation.\n * Returns the cached Blob if token matches; otherwise fetches, updates, and returns new Blob.\n */\nexport const getImage = async (\n  record: ImageRecord,\n  context?: unknown,\n): Promise<Blob | null> => {\n  return handleErrorAsync(async () => {\n    // Attempt to read the cached image from IndexedDB by ID\n    const { id, token, meta } = record\n    const cached = await readImageRecord(id)\n\n    // If a cached image exists and the token matches, return it immediately\n    if (cached && cached.token === token) {\n      const indexedDBRecord = await readImageRecord(id)\n      const encrypted = indexedDBRecord!.encrypted\n\n      // Decrypt the image using the extracted encrypted data and meta\n      const imagePayload = await decryptImage(encrypted, meta)\n\n      // Update lastUsed timestamp (wihtout awaiting)\n      writeImageRecord({\n        ...indexedDBRecord!,\n        lastUsed: Date.now(),\n      })\n\n      // Return the up-to-date Blob for rendering\n      return decryptedPayloadToBlob(imagePayload)\n    }\n\n    // Otherwise, fetch the latest encoded image from the backend\n    const encoded = await fetchEncodedImage(record, context)\n\n    // Decode the wire payload to extract encrypted data, meta, and token\n    const decodedWirePayload = decodeWirePayload(encoded)\n\n    // Ensure response state is Success or Updated; throw on error or not found.\n    if (\n      decodedWirePayload.state !== WirePayloadState.Success &&\n      decodedWirePayload.state !== WirePayloadState.Updated\n    )\n      throw new PixstoreError(\n        `Image fetch failed: state=${\n          WirePayloadState[decodedWirePayload.state] || decodedWirePayload.state\n        } (not Success/Updated)`,\n      )\n\n    // Use the correct token depending on response state (Success uses old token, Updated uses fresh token)\n    const latestToken =\n      decodedWirePayload.state === WirePayloadState.Success\n        ? token\n        : decodedWirePayload.token\n\n    // Prepare the IndexedDB record with fresh encrypted data and token\n    const indexedDBRecord: IndexedDBImageRecord = {\n      id,\n      encrypted: decodedWirePayload.encrypted,\n      token: latestToken,\n      lastUsed: Date.now(),\n    }\n\n    // Save the updated image into the local cache (wihtout awaiting)\n    writeImageRecord(indexedDBRecord)\n\n    // Use the correct meta depending on response state (Success keeps old meta, Updated uses new meta)\n    const latestMeta =\n      decodedWirePayload.state === WirePayloadState.Success\n        ? meta\n        : decodedWirePayload.meta\n\n    // Decrypt the image using the encrypted data and meta from the wire payload.\n    // The `record.meta` is not used, using stale meta could break decryption if the image was recently updated.\n    const imagePayload = await decryptImage(\n      decodedWirePayload.encrypted,\n      latestMeta,\n    )\n\n    // Return the up-to-date Blob for rendering\n    return decryptedPayloadToBlob(imagePayload)\n  })\n}\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h2,{id:"deletecachedimage",children:(0,d.jsx)(n.code,{children:"deleteCachedImage"})}),"\n",(0,d.jsx)(n.p,{children:"Removes an image from the local IndexedDB cache by its ID.\nUseful when you want to manually clear outdated or unused images from the frontend cache."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"description-1",children:"Description"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"export const deleteCachedImage = (\n  id: string\n): Promise<void | null>\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Name"}),(0,d.jsx)(n.th,{children:"Type"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsx)(n.tbody,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"id"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"string"})}),(0,d.jsx)(n.td,{children:"ID of the cached image to delete."})]})})]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"const result = await deleteCachedImage(imageId)\n\nif (result === null) {\n  // For error details, use:\n  console.error(getLastPixstoreError())\n} else {\n  console.log('Image deleted or not found.')\n}\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"how-it-works-1",children:"How it works?"}),"\n",(0,d.jsx)(s.A,{}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"/**\n * Removes a cached image from IndexedDB.\n */\nexport const deleteCachedImage = async (id: string): Promise<void | null> => {\n  return handleErrorAsync(async () => {\n    // Deletes the image record (by ID) from the local IndexedDB cache\n    await deleteImageRecord(id)\n  })\n}\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h2,{id:"cachedimageexists",children:(0,d.jsx)(n.code,{children:"cachedImageExists"})}),"\n",(0,d.jsx)(n.p,{children:"Checks whether a cached image exists in the local IndexedDB by its ID."}),"\n",(0,d.jsx)(n.p,{children:"This can be used to conditionally load or invalidate image data before making a network request."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"description-2",children:"Description"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"export const cachedImageExists = (\n  id: string\n): Promise<boolean | null>\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Name"}),(0,d.jsx)(n.th,{children:"Type"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsx)(n.tbody,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"id"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"string"})}),(0,d.jsx)(n.td,{children:"ID of the image to check in the cache."})]})})]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"const exists = await cachedImageExists(imageId)\n\nif (exists === null) {\n  // For error details, use:\n  console.error(getLastPixstoreError())\n} else if (exists) {\n  console.log('Image is available locally.')\n} else {\n  console.log('Image needs to be fetched.')\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"how-it-works-2",children:"How it works?"}),"\n",(0,d.jsx)(s.A,{}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"/**\n * Returns true if a cached image exists in IndexedDB for the given id.\n */\nexport const cachedImageExists = async (\n  id: string,\n): Promise<boolean | null> => {\n  return handleErrorAsync(async () => {\n    // Checks IndexedDB for an image record with the specified ID\n    return await imageRecordExists(id)\n  })\n}\n"})}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsxs)(n.p,{children:["\ud83d\udcc4 Source: ",(0,d.jsx)(n.a,{href:"https://github.com/sDenizOzturk/pixstore/blob/main/src/frontend/image-service.ts",children:(0,d.jsx)(n.code,{children:"src/frontend/image-service.ts"})})]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},8330:e=>{e.exports={WD:"3.2.1"}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(6540);const d={},a=r.createContext(d);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);