"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[576],{3132:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"usage/backend-crud","title":"Image CRUD on the Backend","description":"Pixstore automatically creates and manages a SQLite database for image metadata, and stores all encrypted image files in your configured directory.","source":"@site/docs/usage/backend-crud.md","sourceDirName":"usage","slug":"/usage/backend-crud","permalink":"/pixstore/docs/usage/backend-crud","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/usage/backend-crud.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"backend-crud","title":"Image CRUD on the Backend","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Initialization","permalink":"/pixstore/docs/usage/initialization"},"next":{"title":"Image CRUD on the Frontend","permalink":"/pixstore/docs/usage/frontend-crud"}}');var t=n(4848),i=n(8453);const s={id:"backend-crud",title:"Image CRUD on the Backend",sidebar_position:2},o=void 0,d={},l=[{value:"How it works",id:"how-it-works",level:2},{value:"Saving an image (buffer-based)",id:"saving-an-image-buffer-based",level:2},{value:"Updating an image (buffer-based)",id:"updating-an-image-buffer-based",level:2},{value:"Deleting an image",id:"deleting-an-image",level:2},{value:"File path convenience wrappers",id:"file-path-convenience-wrappers",level:2},{value:"What does Pixstore automate for you",id:"what-does-pixstore-automate-for-you",level:2}];function c(e){const a={a:"a",blockquote:"blockquote",br:"br",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.p,{children:"Pixstore automatically creates and manages a SQLite database for image metadata, and stores all encrypted image files in your configured directory.\nYou do not need to set up any storage or database manually."}),"\n",(0,t.jsx)(a.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,t.jsx)(a.p,{children:"When you save or update an image:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"The image is encrypted using AES-GCM with a unique key for each image."}),"\n",(0,t.jsx)(a.li,{children:"All encryption details (key, IV, authentication tag, and the image token) are stored in Pixstore\u2019s internal SQLite table."}),"\n",(0,t.jsx)(a.li,{children:"The encrypted image file is saved in your configured image directory."}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"When you delete an image:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Both the encrypted file and all related metadata are permanently removed from storage and database."}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"All these actions are atomic. Pixstore guarantees data integrity at every step."}),"\n",(0,t.jsx)(a.h2,{id:"saving-an-image-buffer-based",children:"Saving an image (buffer-based)"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"import { saveImage } from 'pixstore/backend'\nimport { getLastPixstoreError } from 'pixstore/shared'\n\nconst imageBuffer: Buffer = getImageBufferSomehow_notPixstoreFunction() // e.g. uploaded file, network fetch\nconst imageRecord = await saveImage(imageBuffer)\n\nif (!imageRecord) {\n  // Image could not be saved\n  // For error details, use:\n  console.error(getLastPixstoreError())\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:"Pixstore encrypts the buffer, writes it to disk, and records all metadata."}),"\n",(0,t.jsx)(a.h2,{id:"updating-an-image-buffer-based",children:"Updating an image (buffer-based)"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"import { updateImage } from 'pixstore/backend'\nimport { getLastPixstoreError } from 'pixstore/shared'\n\nconst imageBuffer: Buffer = getImageBufferSomehow_notPixstoreFunction() // e.g. uploaded file, network fetch\nconst updatedRecord = await updateImage(imageId, imageBuffer)\n\nif (!updatedRecord) {\n  // Image not found\n  // For error details, use:\n  console.error(getLastPixstoreError())\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:"The previous file and metadata are overwritten.\nA new key and token are generated automatically."}),"\n",(0,t.jsx)(a.h2,{id:"deleting-an-image",children:"Deleting an image"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"import { deleteImage } from 'pixstore/backend'\nimport { getLastPixstoreError } from 'pixstore/shared'\n\nconst result = await deleteImage(imageId)\n\nif (result === null) {\n  // There was an error during deletion (use getLastPixstoreError() for details)\n  console.error(getLastPixstoreError())\n} else if (result) {\n  console.log('Image deleted.')\n} else {\n  console.log('Image not found.')\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:"Both the encrypted file and its metadata are fully removed."}),"\n",(0,t.jsx)(a.h2,{id:"file-path-convenience-wrappers",children:"File path convenience wrappers"}),"\n",(0,t.jsxs)(a.p,{children:["If you prefer, you can use ",(0,t.jsx)(a.code,{children:"saveImageFromFile"})," and ",(0,t.jsx)(a.code,{children:"updateImageFromFile"})," to work directly with image file paths."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ts",children:"import { saveImageFromFile, updateImageFromFile } from 'pixstore/backend'\n\nconst imageRecord = await saveImageFromFile('./photo.jpg')\nconst updatedRecord = await updateImageFromFile(imageId, './new-photo.jpg')\n"})}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Tip:"}),(0,t.jsx)(a.br,{}),"\n","You can use these helpers with file paths, but reading from and writing to memory (using Buffers) is significantly faster and uses fewer resources than disk I/O. For best performance, prefer buffer-based APIs. Use file path helpers only when your images are already stored on disk."]}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"what-does-pixstore-automate-for-you",children:"What does Pixstore automate for you"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Encryption using AES-GCM with per-image keys"}),"\n",(0,t.jsx)(a.li,{children:"All file operations and directory management with built-in safety"}),"\n",(0,t.jsx)(a.li,{children:"All metadata (key, IV, token, tag) is stored in SQLite"}),"\n",(0,t.jsx)(a.li,{children:"Update and delete always keep file storage and database consistent"}),"\n",(0,t.jsx)(a.li,{children:"All unsafe file names and path traversal attempts are blocked"}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Just call the CRUD methods. Pixstore handles everything else."}),"\n",(0,t.jsx)(a.hr,{}),"\n",(0,t.jsxs)(a.p,{children:["For detailed technical information, see the ",(0,t.jsx)(a.a,{href:"../api-reference/backend/image-service",children:"API Reference section"}),"."]})]})}function u(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>o});var r=n(6540);const t={},i=r.createContext(t);function s(e){const a=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:a},e.children)}}}]);