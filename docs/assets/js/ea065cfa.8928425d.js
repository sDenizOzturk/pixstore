"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[276],{1496:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"usage/integration","title":"Backend \u2194 Frontend Integration","description":"Pixstore securely connects backend and frontend for encrypted image storage and safe, up-to-date image access.","source":"@site/docs/usage/integration.md","sourceDirName":"usage","slug":"/usage/integration","permalink":"/pixstore/docs/usage/integration","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/usage/integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"integration","title":"Backend \u2194 Frontend Integration","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Image CRUD on the Frontend","permalink":"/pixstore/docs/usage/frontend-crud"},"next":{"title":"Default Endpoint & Fetcher","permalink":"/pixstore/docs/usage/default-endpoint"}}');var t=s(4848),r=s(8453);const o={id:"integration",title:"Backend \u2194 Frontend Integration",sidebar_position:4},a=void 0,d={},c=[{value:"How it works",id:"how-it-works",level:2},{value:"Typical integration flow",id:"typical-integration-flow",level:2},{value:"Example",id:"example",level:2},{value:"Stateless proof mechanism",id:"stateless-proof-mechanism",level:2},{value:"Why is it needed?",id:"why-is-it-needed",level:3},{value:"How does it work?",id:"how-does-it-work",level:3},{value:"What should I do?",id:"what-should-i-do",level:3},{value:"Can I skip proof verification?",id:"can-i-skip-proof-verification",level:3},{value:"What does Pixstore automate for you",id:"what-does-pixstore-automate-for-you",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Pixstore securely connects backend and frontend for encrypted image storage and safe, up-to-date image access."}),"\n",(0,t.jsxs)(n.p,{children:["You should ",(0,t.jsx)(n.strong,{children:"never send static image URLs"})," from your backend to your frontend.\nInstead, always provide an up-to-date ",(0,t.jsx)(n.code,{children:"imageRecord"})," object (including id, token, and encryption metadata) in your API responses."]}),"\n",(0,t.jsxs)(n.p,{children:["On the frontend, always use ",(0,t.jsx)(n.code,{children:"getImage(imageRecord)"})," to fetch, decrypt, and cache the image.\nDo not use hardcoded image paths or try to fetch images directly by URL."]}),"\n",(0,t.jsx)(n.p,{children:"This pattern ensures your app always displays the latest, authorized, and securely decrypted image.\nYou do not have to manage storage, security, or cache validation yourself."}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All images are encrypted and stored on the backend using a unique AES-GCM key per image."}),"\n",(0,t.jsx)(n.li,{children:"The encryption key is never saved or persisted on the frontend, not even in IndexedDB."}),"\n",(0,t.jsxs)(n.li,{children:["When the frontend needs to display an image, it must receive an up-to-date ",(0,t.jsx)(n.code,{children:"imageRecord"})," from your API."]}),"\n",(0,t.jsx)(n.li,{children:"Pixstore first checks the IndexedDB cache using the image ID and token."}),"\n",(0,t.jsx)(n.li,{children:"If a valid cached image exists with a matching token, it is returned directly with no network call."}),"\n",(0,t.jsxs)(n.li,{children:["If the image is not cached or the token does not match, Pixstore uses the ",(0,t.jsx)(n.a,{href:"#stateless-proof-mechanism",children:"Stateless proof mechanism"})," to securely fetch the encrypted image and metadata (decryption key, IV, authentication tag, and latest token) from the backend in wire format."]}),"\n",(0,t.jsx)(n.li,{children:"All decryption happens in memory on the frontend. No key or sensitive data is ever saved to IndexedDB."}),"\n",(0,t.jsx)(n.li,{children:"The token ensures that cache is never stale. If an image is updated, the frontend always receives the correct key and token in the new wire payload."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach guarantees:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Strong security:"})," keys never leave the backend except for in-memory decryption"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency:"})," you always get the latest version, even if the image is updated right before your fetch"]}),"\n",(0,t.jsx)(n.li,{children:"No risk of leaking sensitive data in browser cache"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"typical-integration-flow",children:"Typical integration flow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Save or update an image on the backend"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Backend generates or updates the encrypted image and its metadata."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"API returns the imageRecord"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Your backend API always returns an up-to-date imageRecord object in its JSON payload."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Frontend calls ",(0,t.jsx)(n.code,{children:"getImage(imageRecord)"})]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pixstore first checks the IndexedDB cache."}),"\n",(0,t.jsx)(n.li,{children:"If necessary, Pixstore fetches the encrypted image and decryption metadata from the backend, using the stateless proof included in the imageRecord."}),"\n",(0,t.jsx)(n.li,{children:"Only the decrypted image is cached. The key is never written to storage."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Frontend displays the image"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You get a standard Blob to use in ",(0,t.jsx)(n.code,{children:"<img>"})," tags or anywhere else."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Backend:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { getImageRecord } from 'pixstore/backend'\n\napp.get('/api/player/:id', async (req, res) => {\n  const playerId = req.params.id\n  const imageRecord = getImageRecord(playerId)\n  // ...fetch player data from DB\n  res.json({ ...player, imageRecord })\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Frontend:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { getImage } from 'pixstore/frontend'\n\nconst response = await fetch('/api/player/42')\nconst { imageRecord } = await response.json()\n\nconst blob = await getImage(imageRecord)\nif (blob) {\n  const url = URL.createObjectURL(blob)\n  // Use the url in your UI\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"stateless-proof-mechanism",children:"Stateless proof mechanism"}),"\n",(0,t.jsxs)(n.p,{children:["Pixstore uses a ",(0,t.jsx)(n.strong,{children:"stateless proof mechanism"})," to ensure that image requests are authorized and originate from valid frontend flows, not from direct access to public endpoints."]}),"\n",(0,t.jsxs)(n.p,{children:["This mechanism prevents ",(0,t.jsx)(n.strong,{children:"external or unauthorized tools"})," from calling your default or custom image endpoints directly without going through your application logic."]}),"\n",(0,t.jsx)(n.h3,{id:"why-is-it-needed",children:"Why is it needed?"}),"\n",(0,t.jsxs)(n.p,{children:["Pixstore endpoints like ",(0,t.jsx)(n.code,{children:"/pixstore-image/:id"})," are technically accessible by anyone (such as browser or fetch requests),\nbut images should ",(0,t.jsx)(n.strong,{children:"only"})," be retrieved through valid application paths using ",(0,t.jsx)(n.code,{children:"getImage()"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"statelessProof"})," ensures:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Only your ",(0,t.jsx)(n.strong,{children:"authenticated backend"})," can generate image access metadata."]}),"\n",(0,t.jsxs)(n.li,{children:["Only a ",(0,t.jsx)(n.strong,{children:"fresh, valid request"})," from the frontend can successfully load a decrypted image."]}),"\n",(0,t.jsxs)(n.li,{children:["Without a valid proof, the backend responds with a wire payload in ",(0,t.jsx)(n.code,{children:"MissingProof"})," or ",(0,t.jsx)(n.code,{children:"InvalidProof"})," state, and no image data is served."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-does-it-work",children:"How does it work?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Every ",(0,t.jsx)(n.code,{children:"imageRecord"})," sent to the frontend includes a ",(0,t.jsx)(n.code,{children:"statelessProof"})," field."]}),"\n",(0,t.jsxs)(n.li,{children:["The proof is generated ",(0,t.jsx)(n.strong,{children:"per image"}),", using a time-based cryptographic signature."]}),"\n",(0,t.jsxs)(n.li,{children:["It is ",(0,t.jsx)(n.strong,{children:"short-lived"})," and expires quickly (e.g., 20-40 seconds)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"what-should-i-do",children:"What should I do?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Always fetch a fresh ",(0,t.jsx)(n.code,{children:"imageRecord"})," from your backend just before calling ",(0,t.jsx)(n.code,{children:"getImage()"})," on the frontend."]}),"\n",(0,t.jsxs)(n.li,{children:["Do not reuse or persist ",(0,t.jsx)(n.code,{children:"imageRecord"})," values across pages, sessions, or users."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"can-i-skip-proof-verification",children:"Can I skip proof verification?"}),"\n",(0,t.jsxs)(n.p,{children:["If you are using a custom endpoint, you can choose to manually disable proof validation\nby setting ",(0,t.jsx)(n.a,{href:"/docs/api-reference/types#pixstorebackendconfig",children:(0,t.jsx)(n.code,{children:"statelessKeyWindowLength: -1"})})," during ",(0,t.jsx)(n.a,{href:"/docs/api-reference/backend/initialization#initpixstorebackend",children:(0,t.jsx)(n.code,{children:"initPixstoreBackend"})}),"."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Pixstore does not do this by default. You must handle it manually and only in trusted environments like dev tools or internal dashboards."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-does-pixstore-automate-for-you",children:"What does Pixstore automate for you"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Secure end-to-end encrypted image transfer between backend and frontend"}),"\n",(0,t.jsx)(n.li,{children:"Automatic stateless proof generation and validation for secure access"}),"\n",(0,t.jsx)(n.li,{children:"Automatic cache validation and update via tokens"}),"\n",(0,t.jsx)(n.li,{children:"Never persists any key material or secrets on the frontend"}),"\n",(0,t.jsx)(n.li,{children:"Seamless backend to frontend workflow for encrypted images"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Just provide the image record to your frontend. Pixstore handles everything else."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"For advanced integration or security topics, see:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api-reference/types#imagerecord",children:"API Reference - ImageRecord Type"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api-reference/frontend/image-service#how-it-works",children:"API Reference - How getImage works"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);