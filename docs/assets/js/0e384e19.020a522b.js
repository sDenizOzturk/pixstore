"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[976],{2053:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"introduction","title":"Introduction","description":"TypeScript Full Stack Image Storage & Caching Library","source":"@site/docs/intro.md","sourceDirName":".","slug":"/introduction","permalink":"/pixstore/docs/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/sDenizOzturk/pixstore/tree/main/docusaurus/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"introduction","title":"Introduction","sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"Getting Started","permalink":"/pixstore/docs/getting-started"}}');var r=s(4848),t=s(8453);const o={id:"introduction",title:"Introduction",sidebar_position:1},a="Introduction",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"Why Pixstore?",id:"why-pixstore",level:2},{value:"Compatibility",id:"compatibility",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("p",{align:"center",children:(0,r.jsx)("img",{src:"/pixstore/img/logo_w_text.png",width:"400"})}),"\n",(0,r.jsx)("p",{align:"center",children:(0,r.jsx)("em",{children:"TypeScript Full Stack Image Storage & Caching Library"})}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pixstore"})," is a modern, high-performance, and fully secure image storage and caching library for both Node.js backends and browser frontends. It is written in ",(0,r.jsx)(n.strong,{children:"vanilla TypeScript"})," with zero external frameworks or heavy dependencies."]}),"\n",(0,r.jsxs)(n.p,{children:["Pixstore enables ",(0,r.jsx)(n.strong,{children:"end-to-end encrypted"}),", reliable, and scalable image serving for any web app, from simple JavaScript projects to full-stack production systems."]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic browser caching:"})," Transparent IndexedDB cache with token-based invalidation and eviction."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"End-to-end encryption:"})," All images are AES-GCM encrypted, with a unique key per image. Keys never leave the backend by default."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal wire protocol:"})," Efficient, protocol-agnostic binary wire format for image transfer."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stateless secure endpoints:"})," All access is protected by a stateless, time-based proof and per-image tokens. Default endpoint is now secure-by-default."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High performance backend:"})," Uses SQLite for fast, reliable metadata storage and cache."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Production-ready:"})," Includes comprehensive tests and example apps (Vue+Nest, React+Express)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fully extensible:"})," Supports custom endpoints and image fetchers for advanced integrations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal dependencies:"})," Lightweight and easy to audit."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TypeScript native:"})," Full typesafety and strict API design."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Universal API:"})," The same methods and types for both frontend and backend."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"why-pixstore",children:"Why Pixstore?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unified image solution:"})," One library for both backend image storage and frontend caching."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serious security:"})," Images are always encrypted at rest and in transit; only the intended client can decrypt."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"True stateless access:"})," No sessions, cookies, or opaque tokens. All access is cryptographically verifiable."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible integration:"})," Use with any framework or tech stack. Example projects provided."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal friction:"})," Start serving and caching secure images in minutes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actively maintained:"})," Frequent updates and new features based on real-world needs."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Pixstore is ideal for any project needing ",(0,r.jsx)(n.strong,{children:"secure, scalable, and high-performance image handling"}),", from indie webapps to enterprise SaaS."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node.js:"})," v16+ (tested on all current LTS versions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frameworks:"})," Compatible with React, Vue, Next.js, Express, NestJS, and more"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Browsers:"})," Chrome, Firefox, Safari, Edge (latest 2 major versions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module format:"})," ES Modules (ESM) only"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);